<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Big Timer</title>
<style>
  html,body {
    height:100%; margin:0;
    background:transparent; color:#ffffff;
    font-family: 'Inter', 'SF Pro Display', sans-serif;
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
  }
  #timer {
    font-variant-numeric: tabular-nums;
    font-weight:900;
    letter-spacing:2px;
    font-size:18vw;
    text-align:center;
    user-select:none;
    transition:color 0.3s ease;
  }
  #timer.red { color:#ff4040; }
</style>
</head>
<body>
  <div id="timer">00:00</div>
<script>
const qs = new URLSearchParams(location.search);
const wsURL = qs.get('ws') || 'ws://10.11.32.105:4001/ws';
const demo = qs.has('demo');

const el = document.getElementById('timer');
const state = { totalMs: 5*60_000, remainingMs: 5*60_000, status:'Running' };

function fmt(ms){
  // Quantize seconds: floor for +, ceil for - to avoid "-0"
  const signedSeconds = Math.floor(ms / 1000);
  const neg = signedSeconds < 0;
  const abs = Math.abs(signedSeconds);

  const h = Math.floor(abs / 3600);
  const m = Math.floor((abs % 3600) / 60);
  const s = abs % 60;

  const body = h > 0
    ? `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`
    : `${m}:${s.toString().padStart(2,'0')}`;

  return (neg ? '-' : '') + body;
}

function render(){
  el.textContent = fmt(state.remainingMs);
  // Use quantized sign (floor for +, ceil for -) to avoid "-0" wobble and 1s offset
  const signedSeconds = Math.floor(state.remainingMs / 1000);
  el.classList.toggle('red', signedSeconds < 0);
}

function tick(){
  render();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

if (demo){
  // Runs locally without WS connection
  render();
} else {
  let ws;
  function connect(){
    ws = new WebSocket(wsURL);
    ws.onopen = ()=>console.log('[WS] connected');
    ws.onclose = ()=>setTimeout(connect,1500);
    ws.onerror = ()=>ws.close();
    ws.onmessage = e=>{
      try {
        const m = JSON.parse(e.data);
        // Preferred: Ontime "ontime-timer" messages (reference implementation)
        if (m.type === 'ontime-timer' && m.payload) {
          const cur = Number(m.payload.current);
          if (!Number.isNaN(cur)) state.remainingMs = cur;
          // Optional: if Ontime provides status, track it
          if (typeof m.payload.status === 'string') state.status = m.payload.status;
          return;
        }
        // Fallback: older/simple schema { type:'timer', remainingMs, totalMs, status }
        if (m.type === 'timer') {
          if (typeof m.remainingMs === 'number') state.remainingMs = m.remainingMs;
          if (typeof m.totalMs === 'number') state.totalMs = m.totalMs;
          if (typeof m.status === 'string') state.status = m.status;
          return;
        }
        // Initial runtime payload (optional). If present, try to pick current value.
        // Some Ontime endpoints send { type:'ontime', payload:{ timer:{ current: ... } } }
        if (m.type === 'ontime' && m.payload && m.payload.timer && typeof m.payload.timer.current === 'number') {
          state.remainingMs = m.payload.timer.current;
          return;
        }
      } catch(err){
        console.warn('Bad WS message', err);
      }
    };
  }
  connect();
}
</script>
</body>
</html>
